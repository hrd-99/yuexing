---

title: '垃圾回收'
date: 2025-3-21
permalink: /posts/2025/03/垃圾回收/
tags:
  - go
excerpt: "" 
---

**三色标记法**

1. ''**在垃圾回收开始时将根对象标记为灰色**
2. **在灰色对象中选择一个对象标记为黑色，然后将其子对象标记为灰色**
3. **将黑色对象指向的所有白色对象标记为灰色**
4. **重复步骤2和3，直到没有灰色对象**
5. **清除所有白色对象**



若我们希望在并发或增量标记算法中保证标记的正确性，我们需要达成以下其中一种三色不变性：

- 强三色不变性：在标记阶段中，黑色对象不会指向白色对象
- 弱三色不变性：在标记阶段中，黑色对象指向的白色对象（G）必须包含一条灰色对象经过一个或多个白色对象后到达白色对象（G）的路径

**写屏障**在对象引用关系变化时插入额外操作，确保 GC 能正确追踪所有存活对象。

### Dijkstra 插入写屏障**

- **原理**：当修改对象引用（如 `A.field = B`）时，强制将**新引用（B）**标记为存活（灰色）





混合写屏障

插入屏障和删除屏障有以下缺点：

- 插入屏障在扫描结束后还需要 `STW` 一次，将栈内对象重新扫描一遍
- 删除屏障回收精度较低，在回收开始时需要 `STW` 一次，将栈内对象重新扫描一遍, 记录初始快照，保护初始时刻所有存活的对象

为了解决上述问题， `Golang` 引入了混合写屏障，混合写屏障是插入屏障和删除屏障的结合，可以在对象状态发生变化时，通知垃圾回收器。

**工作原理**

1. 在垃圾回收开始时将栈上的对象全部扫描并标记为黑色（不进行二次扫描）
2. 在垃圾回收期间任何栈上创建的对象都会标记为黑色，避免了二次扫描
3. 在垃圾回收期间删除任何的对象都会标记为灰色
4. 在垃圾回收期间创建的任何对象都会标记为灰色

## **. 两种屏障的独立作用**

### **(1) 插入屏障（Dijkstra）单独使用时**

- **核心任务**：确保**新引用**的目标对象被标记。

- 

  问题场景

  ：

  - 初始状态：A（黑）→ B（白），C（白）
  - 操作：`A.field = C`（将A的引用从B改为C）
  - **无插入屏障**：B未被标记，可能被错误回收。
  - **有插入屏障**：强制标记C，但B仍可能丢失（因为A已经是黑色，GC不会重新扫描A）。

### **(2) 删除屏障（Yuasa）单独使用时**

- **核心任务**：确保**旧引用**的目标对象被标记。

- 

  问题场景

  ：

  - 初始状态：A（灰）→ B（白），C（白）
  - 操作：`A.field = C`（删除对B的引用）
  - **无删除屏障**：B未被标记，可能被错误回收。
  - **有删除屏障**：强制标记B，但无法保证新引用C的存活（需额外处理）。

### **场景3：混合屏障**

- 初始状态：A（黑）→ B（白），C（白）

- 操作：

  ```
  A.field = C
  ```

  - 写前：标记B（删除屏障）。
  - 写后：标记C（插入屏障）。
  - **结果**：B和C均存活，无对象丢失

---

title: 'map'
date: 2025-3-21
permalink: /posts/2025/03/map/
tags:
  - go
excerpt: "" 
---

```
┌─────────────┐       ┌───────────────────┐       ┌───────────────────┐
│   hmap      │───────▶       buckets       │───────▶       bmap         │
├─────────────┤       ├───────────────────┤       ├───────────────────┤
│  B (uint8)  │       │  Array of 2^B      │       │  tophash [8]uint8  │
│  count      │       │  bmap pointers     │       │  keys     [8]K     │
│  flags      │       │                   │       │  values   [8]V     │
│  ...        │       └───────────────────┘       │  overflow *bmap    │
└─────────────┘                                   └───────────────────┘

**hmap**：管理桶数组和元数据。
**bmap**：每个桶存储8个键值对，冲突时链式扩展。
```



Go 的 `map` 在以下两种情况下会触发扩容：

1. 

   负载因子过高（默认阈值6.5)

   - 负载因子 = 元素数量 / 桶数量（`count / 2^B`）。
   - 当 `负载因子 > 6.5` 时，说明哈希冲突概率较高，需要扩容。

2. 

   溢出桶过多：

   - 如果溢出桶（`overflow buckets`）的数量超过常规桶（`normal buckets`）的数量，说明哈希分布不均匀，即使负载因子未超标也会触发扩容。

当Map需要扩容时，Go运行时会进行以下步骤：

1. **新桶数组**：分配一个新的、更大的桶数组。新数组的大小通常是原来大小的**两倍**，这有助于分散键值对，减少冲突。
2. **重新哈希**：遍历旧的桶数组中的所有键值对，并使用哈希函数重新计算每个键的位置，将它们插入到新的桶数组中。
3. **逐步迁移**：为了避免在扩容时暂停整个程序，Go的Map实现可能会选择逐步迁移键值对。这意味着在扩容期间，旧的桶数组和新的桶数组会同时存在，新插入的键值对会直接放入新的桶中，而对旧桶的访问会触发迁移操作。
4. **更新内部状态**：一旦所有键值对都迁移到新的桶数组中，Map的内部状态会更新，以反映新的结构。





#### **Hash冲突：**

**根据key（键）即经过一个函数f(key)得到的结果的作为地址去存放当前的key value键值对，但是却发现算出来的地址上已经被占用了。这就是所谓的\**hash冲突\**。**



**开放定址法**
该方法也叫做再散列法，其基本原理是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi 。

**再Hash法**
这种方法就是同时构造多个不同的哈希函数： Hi=RH1（key）  i=1，2，…，k。当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

**链地址法**（Java就是采用这种方法）
其基本思想: 将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

**建立公共溢出区**
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。


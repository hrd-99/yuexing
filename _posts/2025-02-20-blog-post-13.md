---

title: 'GMP'
date: 2024-10-22
permalink: /posts/2025/02/blog-post-13/
tags:
  - go
excerpt: ""  # 这里设置为空，阻止预览
---

<img src="https://hrd-99.github.io/yuexing/images/gmp.png" style="zoom: 33%;" />





|     组件      |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
| G (Goroutine) |        表示一个 Goroutine，包含栈和相关的上下文信息。        |
|  M (Machine)  | 表示一个执行线程，负责将 Goroutine 映射到操作系统的线程上。每个 M 都有自己的调用栈和寄存器状态。 |
| P (Processor) | 表示一个逻辑处理器，维护一个处于可运行状态的 Goroutine 队列。每个 M 都和一个 P 相关联。调度器策略。 |





|            策略            |                             描述                             |
| :------------------------: | :----------------------------------------------------------: |
|         抢占式调度         | 在协程中需要一个协程主动让出 CPU 下一个协程才能使用 CPU。Goroutine 规定一个 Goroutine 每次最多只能占用 10ms 的 CPU，然后就要切换到下一个，防止其他协程长时间不被执行。 |
|          复用线程          | Go 语言的调度器会复用线程，而不是每次都创建新的线程，这样可以减少线程创建和销毁的开销，提高性能。 |
| - 工作偷取 (Work stealing) | 当 M 没有可运行的 G 时，会尝试从其他线程绑定的 P 的本地队列中偷取一半的 G 来运行，而不是销毁 M。 |
|   - 挂起机制 (Hand off)    | 当 G 由于系统调用而阻塞时，M 会释放绑定的 P 供其他 M 使用。  |
|            并行            | 通过 `GOMAXPROCS` 配置 P 的数量，从而实现并行执行。P 的数量决定了并行度，P 的数量等于 CPU 核数时，可以实现最大并行度。 |
|          全局队列          | 当本地队列中没有可运行的 G，M 会先去全局队列尝试获取 G。若全局队列中没有待运行的 G，则会尝试去其他 P 的本地队列中偷取 G。 |
